//Ass2 SetA 
//count
#include<stdio.h>
#include<unistd.h>            // for fork(),exclp()
#include<fcntl.h>        // O_RDONLY
#include<stdlib.h>      //exit()
void count(char c, char *fn)
{
	int lc=0,wc=0,cc=0,handle;
	char ch;
	if((handle=open(fn,O_RDONLY))==-1)
	{
		printf("File %s not found\n",fn);
		return;
	}
	while(read(handle,&ch,1)!=0)
	{
		if(ch==' '|| ch=='\n')
			wc++;
                else 
			cc++;

		if(ch=='\n')
			lc++;
	}
	close(handle);
	switch(c)
	{
	case 'c':
			printf("Total No.of Characters = %d\n",cc);
			break;
	case 'w':
			printf("Total No.of Words = %d\n",wc);
			break;
	case 'l':
			printf("Total No.of Lines = %d\n",lc);
			break;
	}
}

main()
{
	char command[80],t1[20],t2[20],t3[20],t4[20];
	int n;
	system("clear");
	while(1)
	{
		printf("myShell$");
		//fflush(stdin);
		fgets(command,80,stdin);
		n = sscanf(command,"%s %s %s %s",t1,t2,t3,t4);
		switch(n)
		{
		case 1:
                         if(strcmp(t1,"exit")==0)
                                 exit(1);      
			if(!fork())
			{
				execlp(t1,t1,NULL);
				perror(t1);
			}
			break;
		case 2:
			if(!fork())
			{
				execlp(t1,t1,t2,NULL);
				perror(t1);
			}
			break;
		case 3:
			if(strcmp(t1,"count")==0)
				count(t2[0],t3);
			else
			{
				if(!fork())
				{
					execlp(t1,t1,t2,t3,NULL);
					perror(t1);
				}
			}
			break;
		case 4:
			if(!fork())
			{
				execlp(t1,t1,t2,t3,t4,NULL);
				perror(t1);
			}
		}
	}
}


//Ass2 SetB
//list
#include<stdio.h>
#include<sys/stat.h> //S_IFREG
#include<unistd.h>  //exclp()
#include<dirent.h>   //DIR
#include<stdlib.h>  //exit()
void list(char c, char *dn)
{
	DIR *dir;
	int cnt=0;
	struct dirent *entry;
	struct stat buff;
	if((dir=opendir(dn))==NULL)
	{
		printf("Directory %s not found\n",dn);
		return;
	}
	switch(c)
	{
	case 'f':
		while((entry=readdir(dir))!=NULL)
		{
			stat(entry->d_name,&buff);  //display file or file system status
			if(S_IFREG&buff.st_mode)
				printf("%s\n",entry->d_name);
		}
		break;
	case 'n':
		while((entry=readdir(dir))!=NULL)
			cnt++;
		printf("Total No.of Entries = %d\n",cnt);
		break;
	case 'i':
		while((entry=readdir(dir))!=NULL)
		{
			stat(entry->d_name,&buff);
			if(S_IFREG&buff.st_mode)
				printf("%s\t%d\n",entry->d_name,buff.st_ino);
		}
		break;
	default:
		printf("Invalid argument...\n");
	}
	closedir(dir);
}

main()
{
	char command[80],t1[20],t2[20],t3[20],t4[20];
	int n;
	system("clear");
	while(1)
	{
		printf("myShell$");
		fflush(stdin);
		fgets(command,80,stdin);
		n = sscanf(command,"%s %s %s %s",t1,t2,t3,t4);
		switch(n)
		{
		case 1:if(strcmp(t1,"exit")==0)
                                 exit(1);      
			if(!fork())
			{
				execlp(t1,t1,NULL);
				perror(t1);
			}
			break;
		case 2:
			if(!fork())
			{
				execlp(t1,t1,t2,NULL);
				perror(t1);
			}
			break;
		case 3:
			if(strcmp(t1,"list")==0)
				list(t2[0],t3);
			else
			{
				if(!fork())
				{
					execlp(t1,t1,t2,t3,NULL);
					perror(t1);
				}
			}
			break;
		case 4:
			if(!fork())
			{
				execlp(t1,t1,t2,t3,t4,NULL);
				perror(t1);
			}
		}
	}
}




//Ass2 SetC Q2
//search
#include<stdio.h>
#include<unistd.h> //execlp()
#include<fcntl.h>  //O_RDONLY
#include<stdlib.h>  //exit()
#include<string.h>  //strstr()

void search(char c, char *s, char *fn)
{
	int handle,i=1,cnt=0,j=0;
	char ch,buff[80],*p;
	if((handle=open(fn,O_RDONLY))==-1)
	{
		printf("File %s not found\n",fn);
		return;
	}
	switch(c)
	{
	case 'f':
		while(read(handle,&ch,1)!=0)
		{
			if(ch=='\n')
			{
				buff[j]='\0';
				j=0;
				if(strstr(buff,s)!=NULL)
				{
					printf("%d : %s\n",i,buff);
					break;
				}
				i++;
			}
			else
				buff[j++]=ch;
		}
		break;
	case 'c':
		while(read(handle,&ch,1)!=0)
		{
			if(ch=='\n')
			{
				buff[j]='\0';
				j=0;
				if(strstr(buff,s)!=NULL)
				{
					p=buff;
					while((p=strstr(p,s))!=NULL)
					{
						cnt++;
						p++;
					}
				}
			}
			else
				buff[j++]=ch;
		}
		printf("Total No.of Occurrences = %d\n",cnt);
		break;
	case 'a':
		while(read(handle,&ch,1)!=0)
		{
			if(ch=='\n')
			{
				buff[j]='\0';
				j=0;
				if(strstr(buff,s)!=NULL)
					printf("%d : %s\n",i,buff);
				i++;
			}
			else
				buff[j++]=ch;
		}
	}
	close(handle);
}

main()
{
	char command[80],t1[20],t2[20],t3[20],t4[20];
	int n;
	system("clear");
	while(1)
	{
		printf("myShell$");
		fflush(stdin);
		fgets(command,80,stdin);
		n = sscanf(command,"%s %s %s %s",t1,t2,t3,t4);
		switch(n)
		{
		case 1:if(strcmp(t1,"exit")==0)
                                 exit(1);  
			if(!fork())
			{
				execlp(t1,t1,NULL);
				perror(t1);
			}
			break;
		case 2:
			if(!fork())
			{
				execlp(t1,t1,t2,NULL);
				perror(t1);
			}
			break;
		case 3:
			if(!fork())
			{
				execlp(t1,t1,t2,t3,NULL);
				perror(t1);
			}
			break;
		case 4:
			if(strcmp(t1,"search")==0)
				search(t2[0],t3,t4);
			else
			{
				if(!fork())
				{
					execlp(t1,t1,t2,t3,t4,NULL);
					perror(t1);
				}
			}
		}
	}
}



//typeline
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <dirent.h>
#include <unistd.h>
int make_toks(char *s, char *tok[]) 
{ 
 int i = 0; 
 char *p; 
 p = strtok(s, " "); 
while(p != NULL) 
{ 
 tok[i++] = p; 
 p = strtok(NULL, " "); 
} 
tok[i] = NULL; 
return i; 
} 
void typeline(char *op, char *fn) 
{ 
 int fh, i, j, n; 
 char c; 
fh = open(fn, O_RDONLY); 
if(fh == -1) 
{ 
printf("File %s not found.\n", fn); 
return; 
} 
if(strcmp(op, "a") == 0) 
{ 
 while(read(fh, &c, 1) > 0) 
 printf("%c", c); 
 close(fh); 
 return; 
} 
n = atoi(op); 
if(n > 0) 
{ 
 i = 0; 
 while(read(fh, &c, 1) > 0) 
 { 
 printf("%c", c); 
 if(c == '\n') 
 i++; 
 if(i == n) 
 break; 
} 
} 
if(n < 0) 
{ 
 i = 0; 
 while(read(fh, &c, 1) > 0) 
 { 
 if(c == '\n') i++; 
 } 
 lseek(fh, 0, SEEK_SET); 
j = 0; 
while(read(fh, &c, 1) > 0) 
{ 
 if(c == '\n') 
 j++; 
 if(j == i+n+1) 
 break; 
} 
while(read(fh, &c, 1) > 0) 
{ 
 printf("%c", c); 
} 
} 
close(fh); 
} 
int main() 
{ 
 char buff[80], *args[10]; 
 while(1) 
 { 
 printf ("\n"); 
 printf("\nmyshell$ "); 
 fgets(buff, 80, stdin); 
 buff[strlen(buff)-1] = '\0'; 
 int n = make_toks(buff, args); 
 switch (n) 
 { 
 case 1: if(strcmp(args[0], "exit") == 0) 
exit(1); 
if (!fork()) 
execlp (args [0], args[0], NULL); 
break; 
 case 2: 
if (!fork ()) 
execlp (args [0], args[0], args[1], NULL); 
break; 
 case 3: if (strcmp(args[0], "typeline") == 0) 
 typeline (args[1], args[2]); 
else
{ 
 if (!fork ()) 
execlp (args [0], args[0], args[1], args[2], NULL); 
} 
break; 
case 4: 
if (!fork ()) 
execlp (args [0], args [0], args [1], args [2], args [3], NULL); 
break; 
} 
} 
return 0; 
} 




















